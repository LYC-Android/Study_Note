001
类加载器ClassLoader:
1.加载类的一个东西，用于加载Class文件，编写代码->编译成class文件->由类加载器装载到内存里面

2.当我们Eclipse右键运行的时候，会启动一个Java虚拟机的进程(exe文件)
如下集中情况下，Java虚拟机将结束生命周期
--执行system.exit()方法
--程序正常执行结束
--程序在执行过程中遇到了异常或错误而异常终止
--由于操作系统出现错误而导致Java虚拟机进程终止

类的加载、连接与初始化:(从硬盘上的一个class文件到，一直到能被正常执行，在执行之前会经历这3个过程)
加载:查找并加载类的二进制数据(即将class的字节码信息加载到内存里面)
连接:
--验证:确保被加载的类的正确性(一般来说，可能会认为这个步骤是多余的，因为我们无论是用javac或者Eclipse如果编译不通过都会报错的出不来class文件，可是这防止有些人自己写一个class文件，所以这一步是必须要的)
--准备:为类的静态变量(而不是实例变量,此外由于不管你new多少个对象,静态变量都是只有1份的,同时也不管你有没有new对象，他这一份也是有得，所以说这里并没有说要实例化对象分配内存，因为当你为一个实例变量分配内存的时候肯定这3步已经走完了他才可以分配内存的)分配内存,并将其初始化为默认值(即boolean为false，int为0等)。
--解析，把类中的符号引用转换为直接引用
初始化:为类的静态变量赋予正确的初始值(看似和准备的那一步重合，其实并不是的。这里是正确的初始值,比如,你声明了一个静态变量int=1，那么执勤啊的准备阶段是赋值为0，初始化赋值为1)


Java程序对类的使用方式可分为两种
--主动使用
--被动使用
所有的Java虚拟机实现必须在每个类或接口被Java程序"首次主动使用"时才初始化他们

主动使用(6种)
--创建类的实例
--访问某个类的接口的静态变量,或者对该静态变量赋值
--调用类的静态方法
--反射(如 Class.forName("com.example.lyc"))
--初始化一个类的子类
--Java虚拟机启动时被标明为启动类的类(JavaTest)

除了以上六种情况,其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化

类的加载是指将类的.class文件中的二进制数据读入到内存中,将其放在运行时数据区的方法区内,然后在堆区创建一个java.lang.Class对象,用来封装类在方法区内的数据结构

类的加载
加载.class文件的方式
--从本地系统中直接加载
--通过网络下载.class文件----UrlClassLoader类
--从zip,jar等归档文件中加载.class文件
--从专有数据库中提取.class文件
--将Java源文件动态编译为.class文件(一般应用于web开发)

类的加载的最终产品是位于堆区中的Class对象
Class对象封装了类在方法区内的数据结构，并且向Java程序猿提供了访问方法区内的数据结构的接口(即各种反射的接口,包括各种私有变量，普通方法，构造方法等)

有两种类型的类加载器
--Java虚拟机自带的加载器(即默认的类加载器)
Ⅰ根类加载器(Bootstrap)
Ⅱ扩展了加载器(Extension)
Ⅲ系统类加载器(System)(应用加载器)

-用户自定义的类加载器
Java.lang.ClassLoader的子类
用户可以定制类的加载方式

类的加载器并不要等到某个类被"首次主动使用"时再加载它
JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误,类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)
如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误(一般用于比如说你在JDK1.6编译过了，然后部署到JDK1.5的时候可能会产生上述所说的一个不兼容的问题)

类被加载过后,就进入连接阶段。连接就是将已经读入到内存的二进制数据合并到虚拟机的运行时环境中去。
类的验证的内容(其实这一部主要是防止而已用户瞎鸡巴搞的。因为正常用户的话生成的class文件都是经过编译的，可是这并不妨碍某些人瞎鸡巴搞。所以这一部是防止这些瞎鸡巴搞的人所设置的)
-类文件的结构的检查
-语义检查
-字节码验证
-二进制兼容性的验证


类的准备
 在准备阶段,Java虚拟机为类的静态变量分配内存,并设置默认的初始值。

 类的解析
 在解析阶段,Java虚拟机会把类的二进制数据中的符号引用替换为直接引用。例如在Worker类的gotoWork()方法中会引用Car类的run()方法
public void gotoWork(){
	car.run();//这段代码在Workder类的二进制数据中表示为符号引用
}
在Worker类的二进制数据中，包含了一个对Car类的run()方法的符号引用，它有run()方法的全名和相关描述符组成。在解析阶段，Java虚拟机会把这个符号引用替换为一个指针，该指针指向Car类的run()方法在方法区内的内存位置，该指针就是直接引用


在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径:（1）在静态变量声明处进行初始化；（2）在静态代码块中进行初始化。


类的初始化
类的初始化步骤
Ⅰ假如这个类还没有被加载和连接,那就先进行加载和连接。
Ⅱ假如类存在直接的父类,并且这个父类还没有被初始化,那就先初始化直接的父类(反正急住，一个子类只要可以用那么他的父类一定都已经初始化了的。最顶层到Object)
Ⅲ假如类中存在初始化语句,那就一次执行这些初始化语句

当Java虚拟机初始化一个类时，要求他的所有的父类都已经卑初始化，但是这条规则并不适用于接口。
在初始化一个类时，并不会先初始化它所实现的接口
在初始化一个接口，并不会先初始化它的父接口
因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才回导致该接口的初始化

只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时,才可以认为是对类或接口的主动使用(即,比如child继承了Parents，这个时候Parent中有一个int a=3;如果这个时候访问方式为child.a;那么就不会导致子类child被初始化，因为这个a实际上并不存在于child类中)

类的初始化时机
调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化

类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加在过程采用父委托机制,这种机制能更好地保证Java平台的安全。在此委托机制中，除了Java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当Java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则有父加载器完成加载任务，否则才由加载器loader1本身加载Sample类

类加载器
Java虚拟机自带了以下几种加载器
根(Bootstrap)类加载器:该加载器没有父加载器。他负责加载虚拟机的核心类库,如Java.lang.*等。例如,java.lang.Object就是由根加载器加载的。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统,属于虚拟机的实现的一部分,它并没有继承java.lang.ClassLoader类

扩展(Extension)类加载器:它的父加载器为根类加载器.它从java.ext.dirs系统属性所指定的目录中加载类库,或者从JDK的安装目录的jre\lib\ext子目录(扩展目录)下加载类库,如果把用户创建的JAR文件放在这个目录下,也会自动由扩展类加载器加载。扩展类加载器是纯Java类，是java.lang.ClassLoader类的子类

系统(System)类加载器:也称为应用类加载器,它的父加载器为扩展类加载器。它从环境变量classpath或者系统水泥工java.class.path所指定的目录中加载类,它是用户自定义的类加载器的默认父加载器。系统加载器是纯Java类，是java.lang.ClassLoader类的子类

父子加载器并非继承关系,也就是说子加载器不一定继承了父加载器

除了以上虚拟机自带的加载器以外,用户还可以定制自己的类加载器(User-defined Class Loader).Java提供了抽象类java.lang.ClassLoader,所有用户自定义的类加载器应该继承ClassLoader类

Class sampleClass=loader2.loadClass("Sample");
loader2首先从自己的命名空间查找Sample类是否已经被加载,如果已经加载,就直接返回代表Sample类的Class对象的引用。
如果Sample类还没有被加载,loader2首先请求loader1代为加载,loader1再请求系统类加载器代为加载,系统类加载器再请求扩展类加载器代为加载,扩展类加载器再请求根类加载器代为加载。若根类加载器和扩展类加载器都不能加载，则系统类加载器尝试加载,若能加载成功,则将Sample类所对应的Class对象的引用返回给loader1，loader1再将引用返回给loader2,从而成功将Sample类加载进虚拟机。若系统类加载器不能加载Sample类，则loader1尝试加载Sample类,若loader1也不能成功加载,则loader2尝试加载。若素有的父加载器及loader2本身都不能加载,则抛出ClassNotFoundException异常
     根加载器
       /|\
        |
     扩展类加载器 
       /|\
        |  
     系统加载器
       /|\
        |     加载
     loader1 - - ->Sample类
       /|\
        |  
     loader2 

若有一个类加载器能成功加载Sample类,那么这个类加载器被成为定义类加载器,所有能成功返回Class对象的引用的类加载器(包括定义类加载器)都被称为初始类加载器

假设
loader1实际加载了Sample类,则loader1为Sample类的定义类加载器,loader2和loader1为Sample的初始类加载器

需要指出的是,加载器之间的父子关系实际上是值的是加载器对象之间的包装关系,而不是类之间的继承关系。一对父子加载器可能是同一个加载器类的两个实例,也可能不是。在加载器中包装了一个父加载器对象。例如以下loader1和loader2都是MyClassLoader类的实例，并且loader2包装了loader1,loader1是loader2的父加载器

当生成一个自定义的类加载器时，如果没有指定它的父加载器，那么系统加载器就将成为该类加载器的父加载器。

父委托机制的有点是能够提高软件系统的安全性.因为在此机制下,用户自定义的类加载器不可能加载应该由父加载器加载的可靠类,从而防止不可靠甚至恶意的代码代替由父加载器加载的可靠代码.例如,java.lang.Object类总是由根类加载器加载,其他任何用户自定义的类的加载器都不可能加载含有恶意代码的java.lang.Object类

每个类加载器都有自己的命名空间,命名空间由该类加载器及所有父加载器所加载的类组成。在同一命名空间中,不会出现类的完整名字(包括类的包名)相同的两个类;在不同的命名空间中,有可能会出现类的完整名字(包括类的包名)相同的两个类

由同一类加载器加载的属于相同包名的类组成了运行时包。决定两个类是不是属于同一个运行时包,不仅要看它们的包名是否相同,还要看定义类加载器是否相同。只有属于同一运行时包的类才能互相访问包可见(即默认访问级别)的类和类成员。这样的限制能避免用户自定义的类冒充核心类库的类,去访问核心类库的包可见成员。假设用户自定义了一个类java.lang.Spy,并由用户自定义的类加载器加载,由于java.lang.Spy和核心库类java.lang.*由不同的加载器加载,它们属于不同的运行时包,所以java.lang.Spy不能访问核心类库java.lang包中的包可见成员。

创建用户自定义的类加载器
  要创建用户自己的类加载器,只需要扩展java.lang.ClassLoader类,然后覆盖它的findClass(String name)方法即可,该方法根据参数指定的类的名字,返回对应的Class对象的引用。


反射
Java反射机制是指在运行状态中,对于任意一个类,都能够知道这个类的所有属性和方法;对于任何一个对象，都能够调用它的任意一个方法和属性;这种动态获取的信息以及动态调用对象的方法功能成为Java语言的反射机制。
用一句话总结就是反射可以实现运行时可以知道任意一个类的属性和方法。

Class c1=Code.class;
这说明任何一个类都有一个隐含的静态成员变量class(位于堆区,在类的加载的时候生成,用于描述方法区内的数据结构,有且只有唯一的一个),这种方事是通过获取类的静态成员变量class得到的

